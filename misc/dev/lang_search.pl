#!/usr/bin/perl

=head1 NAME

  lang_search.pl

=head1 SYNOPSIS

  Language keys search

  Dev Tool for:
    1) Duplicate keys search
       core -> modules, modules <-> modules
    2) Unused lang search

=head1 OPTIONS

  PATH       - config search path
    default: /usr/abills/
  DUPLICATES - duplicate keys search
  UNUSED     - unused keys search
  IGNORE_KEYS - ignored keys
    example: VOLTAGE,RAM_USAGE,TEMPERATURE

=cut

use strict;
use warnings FATAL => 'all';

BEGIN {
  use FindBin '$Bin';
  our $libpath = $Bin . '/../../';

  unshift(@INC,
    $libpath . '/lib/',
    $libpath
  );
}

use JSON;
use File::Find;

use Abills::Base qw/parse_arguments/;

our %LANG_KEYS = (
  core    => {},
  modules => {},
);

our %USED_LANG_KEYS = (
  core    => [],
  modules => {}
);

our @REGEXPS = (
  # For core vocabularies
  qr/(.+)\.pl$/,
  # For module vocabularies
  qr/^lng_(.+)\.pl$/,
);

our @KEYS_REGEXPS = (
  qr/\$lang\{(.+?)\}/m,
  qr/\$lang->\{(.+?)\}/m,
  qr/\{lang\}\{(.+?)\}/m,
  qr/\{lang\}->\{(.+?)\}/m,
  qr/_\{(.+?)\}_/m,
  # Errors.pm
  qr/ \d+ => '(.+?)'/m
);

our @ALLOWED_FILENAMES = ('webinterface', 'config', 'periodic');
# .tpl - parse special _{(.+?)}_ variables
# .sql - parse standard statuses
our @ALLOWED_EXTENSIONS = ('tpl', 'pm', 'pl', 't', 'cgi', 'sql');

# Exceptions
# Some keys usage cant be defined by lang keys, may generated by code.
# List is not final, it needs to be supplemented.
our @IGNORE_KEYS = (
  'VOLTAGE',
  'RAM_USAGE',
  'TEMPERATURE',
  'UPTIME'
);

my $args = parse_arguments(\@ARGV);
my $base_dir = $args->{PATH} // '/usr/abills';
my $language_dir = "$base_dir/language";
my $modules_dir = "$base_dir/Abills/modules";

start();

#**********************************************************
=head2 start()

=cut
#**********************************************************
sub start {
  # Collect lang keys
  my @DIRS = ($language_dir, );
  my $options = { wanted => sub { file_search(0, @_)} };
  find($options, @DIRS);

  @DIRS = ($modules_dir, );
  $options = { wanted => sub { file_search(1, @_)} };
  find($options, @DIRS);

  my $json = _get_configured_json();

  if ($args->{IGNORE_KEYS}) {
    @IGNORE_KEYS = split(/,\s?/, $args->{IGNORE_KEYS});
  }

  if ($args->{DUPLICATES}) {
    my ($duplicates, $duplicates_between_modules) = lang_search_duplicates(\%LANG_KEYS);

    print $json->encode({
      core_to_modules    => $duplicates,
      modules_to_modules => $duplicates_between_modules
    });
  }
  elsif ($args->{UNUSED}) {
    my $unused_keys = lang_search_unused(\%LANG_KEYS, \%USED_LANG_KEYS);

    print $json->encode($unused_keys);
  }
  else {
    help();
  }
}

#**********************************************************
=head2 file_search($is_module)

  Arguments:
    $is_module

=cut
#**********************************************************
sub file_search {
  my ($is_module) = @_;
  my $name = $File::Find::name;
  my $dir = $File::Find::dir;

  if (-d $name) {
    return 1;
  }

  my $file_name = substr($name, length($dir) + 1);

  if ($file_name =~ $REGEXPS[$is_module]) {
    my $language = $1;
    my $module = $is_module ? substr($dir, length($modules_dir) + 1) : '';
    file_process($name, $language, $module);
    return 1;
  }
}

#**********************************************************
=head2 file_process($file_path, $lang, $module)

  Arguments:
    $file_path
    $lang
    $module?

=cut
#**********************************************************
sub file_process {
  my ($file_path, $lang, $module) = @_;

  open(my $fh, '<', $file_path);
  while(<$fh>) {
    my ($matched) = $_ =~ /\$lang\{(.+?)\}/;
    if ($matched) {
      if ($module) {
        $LANG_KEYS{modules}->{$module} //= {};
        $LANG_KEYS{modules}->{$module}->{$lang} //= [];

        push @{$LANG_KEYS{modules}->{$module}->{$lang}}, $matched;
      }
      else {
        $LANG_KEYS{core}->{$lang} //= [];
        push @{$LANG_KEYS{core}->{$lang}}, $matched;
      }
    }
  }
  close($fh);
}

#**********************************************************
=head2 lang_search_duplicates($data)

  Arguments:
    $data: object  - hash of lang keys from core and modules

  Returns:
    ($duplicates_core, $duplicates_modules)

=cut
#**********************************************************
sub lang_search_duplicates {
  my ($data) = @_;

  my $core = $data->{core};
  my $modules = $data->{modules};

  my %DUPLICATES_CORE = ();
  my %DUPLICATES_MODULES = ();

  # Check duplicates from core to modules
  for my $lng (sort keys %$core) {
    for my $core_lng_key (@{$core->{$lng}}) {
      for my $module (sort keys %$modules) {
        if (grep { $_ eq $core_lng_key } @{$modules->{$module}->{$lng}}) {
          if (!grep { $_ eq $module } @{$DUPLICATES_CORE{$core_lng_key}}) {
            push @{$DUPLICATES_CORE{$core_lng_key}}, $module;
          }
        }
      }
    }
  }

  # Check duplicates from module to modules
  for my $lng (sort keys %$core) {
    foreach my $module (sort keys %$modules) {
      my $array = $modules->{$module}->{$lng};
      foreach my $lng_key (@$array) {
        if (exists $DUPLICATES_MODULES{$lng_key} && !grep { $_ eq $module } @{$DUPLICATES_MODULES{$lng_key}}) {
          push @{$DUPLICATES_MODULES{$lng_key}}, $module;
        }
        else {
          $DUPLICATES_MODULES{$lng_key} = [ $module ];
        }
      }
    }
  }

  foreach my $value (keys %DUPLICATES_MODULES) {
    if (scalar(@{$DUPLICATES_MODULES{$value}}) < 2) {
      delete $DUPLICATES_MODULES{$value};
    }
  }

  return (\%DUPLICATES_CORE, \%DUPLICATES_MODULES);
}

#**********************************************************
=head2 code_file_search()

=cut
#**********************************************************
sub code_file_search {
  my $name = $File::Find::name;
  my $dir = $File::Find::dir;

  if (-d $name) {
    return 1;
  }

  # Skip language folder.
  if (index($dir, $language_dir) != -1) {
    return 1;
  }

  my $file_name = substr($name, length($dir) + 1);

  # Skip module dictionaries.
  if (index($file_name, 'lng_') != -1) {
    return 1;
  }

  if (grep { $_ eq $file_name } @ALLOWED_FILENAMES) {
    code_file_process($name, $dir);
    return 1;
  }

  my ($extension) = $name =~ /([^.]+)$/;

  if (grep { $_ eq $extension } @ALLOWED_EXTENSIONS) {
    code_file_process($name, $dir);
    return 1;
  }
}

#**********************************************************
=head2 code_file_process()

=cut
#**********************************************************
sub code_file_process {
  my ($file_path, $dir) = @_;

  my $is_module = index($dir, $modules_dir) != -1;
  my $module = '';
  if ($is_module)  {
    my $module_index = index($dir, '/', length($modules_dir) + 1) - length($modules_dir);
    my $module_name_index = $module_index > 0 ? $module_index -1 : length($dir) - length($modules_dir);

    $module = substr($dir, length($modules_dir) + 1, $module_name_index)
  };

  open(my $fh, '<', $file_path);
  while(<$fh>) {
    for my $regex (@KEYS_REGEXPS) {
      my @matches = $_ =~ /$regex/g;
      for my $match (@matches) {
        if ($module) {
          $USED_LANG_KEYS{modules}->{$module} //= [];

          if (!grep { $_ eq $match } @{$USED_LANG_KEYS{modules}->{$module}}) {
            push @{$USED_LANG_KEYS{modules}->{$module}}, $match;
          }
        }
        else {
          if (!grep {$_ eq $match } @{$USED_LANG_KEYS{core}}) {
            push @{$USED_LANG_KEYS{core}}, $match;
          }
        }
      }
    }
  }
  close($fh);
}

#**********************************************************
=head2 lang_search_unused($all_keys, $used_keys)

  Arguments:
    $all_keys: hash  - lang keys from core and modules
    $used_keys: hash - used lang keys need to be filled

  Returns:
    $all_keys - cleaned keys

=cut
#**********************************************************
sub lang_search_unused {
  my ($all_keys, $used_keys) = @_;

  my @DIRS = ($base_dir, );
  my $options = { wanted => \&code_file_search };

  find($options, @DIRS);

  clean_used_langs($all_keys, $used_keys);

  return $all_keys;
}

#**********************************************************
=head2 clean_used_langs($all_keys, $used_keys)

  Arguments:
    $all_keys: hash  - lang keys from core and modules
    $used_keys: hash - used lang keys, filled

=cut
#**********************************************************
sub clean_used_langs {
  my ($all_keys, $used_keys) = @_;

  my $core_all = $all_keys->{core};
  my $modules_all = $all_keys->{modules};

  my $core_used = $used_keys->{core};
  my $modules_used = $used_keys->{modules};

  # core + etc -> core + etc
  for my $lng (keys %$core_all) {
    for (my $i = 0; $i < @{$core_all->{$lng}}; $i++) {
      my $key = $core_all->{$lng}->[$i];

      if ((grep { $_ eq $key } @$core_used) || (grep { $_ eq $key } @IGNORE_KEYS)) {
        splice(@{$core_all->{$lng}}, $i, 1);
        $i--;
      };
    }
  }

  # core + etc -> /modules
  for my $lng (keys %$core_all) {
    for my $module (keys %$modules_all) {
      for (my $i = 0; $i < @{$core_all->{$lng}}; $i++) {
        my $key = $core_all->{$lng}->[$i];
        if ((grep { $_ eq $key } @{$modules_used->{$module}}) || (grep { $_ eq $key } @IGNORE_KEYS)) {
          splice(@{$core_all->{$lng}}, $i, 1);
          $i--;
        }
      }
    }
  }

  for my $module (keys %$modules_all) {
    for my $lng (keys %$core_all) {
      if (!$modules_all->{$module}->{$lng}) {
        next;
      }
      for (my $i = 0; $i < @{$modules_all->{$module}->{$lng}}; $i++) {
        my $key = $modules_all->{$module}->{$lng}->[$i];

        # /modules -> /modules
        # /modules -> core + etc
        if ((grep { $_ eq $key } @{$modules_used->{$module}}) || (grep { $_ eq $key } @$core_used) || (grep { $_ eq $key } @IGNORE_KEYS)) {
          splice(@{$modules_all->{$module}->{$lng}}, $i, 1);
          $i--;
        }
      }
    }
  }

}

#**********************************************************
=head2 help()

=cut
#**********************************************************
sub help {
  print << "[END]";
  Language keys search

  Dev Tool for:
  1) Duplicate keys search
     core -> modules, modules <-> modules
  2) Unused lang search

  Params:
    PATH       - config search path
      default: /usr/abills/
    DUPLICATES - duplicate keys search
    UNUSED     - unused keys search
    IGNORE_KEYS - ignored keys
      example: VOLTAGE,RAM_USAGE,TEMPERATURE
[END]
}


#**********************************************************
=head2 _get_configured_json()

  Returns:
    JSON

=cut
#**********************************************************
sub _get_configured_json {
  JSON->new->utf8->space_before(0)->space_after(1)->indent(1)->canonical(1)
}

1;
