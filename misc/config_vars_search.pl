#!/usr/bin/perl

=head1 NAME

  config_vars_search.pl

=head1 SYNOPSIS

   Config Vars Search
   Dev Tool for searching config variables in files

=head1 OPTIONS

  PATH - config search path
    default: /usr/abills/
  BY_MODULES - split config into %module%.json, searching by PATH + /Abills/modules
    optional
  CREATE_DIFF - create diff_%date%.json from existing abills.json
    optional
  get_docs    - docs by whole confs from config_variables.sql, can take to 10 minutes
  no_docs     - variables which doesnt have descriptions, but possibly have pages
  no_page     - variables which doesnt have any pages
  CACHE       - path to .json generated by get_docs for no_docs AND no_page options
=cut

use strict;
use warnings FATAL => 'all';

BEGIN {
  our $libpath = '../';
  unshift(@INC,
    $libpath . '/lib/',
    $libpath
  );
}

use File::Find;
use POSIX 'strftime';
use JSON;
use FindBin '$Bin';


use Abills::Base qw/parse_arguments/;
use Abills::Fetcher qw/web_request/;

our %CONFIG_DATA = ();
our @ALLOWED_FILENAMES = ('webinterface', 'config', 'periodic');
our @ALLOWED_EXTENSIONS = ('tpl', 'pm', 'pl', 't', 'cgi');

our @REGEXPS = (
  qr/\$conf\{(.+?)\}/,
  qr/\{conf\}\{(.+?)\}/,
  qr/\$СONF->\{(.+?)\}/,
  qr/\$Сonf->\{(.+?)\}/,
  qr/\$conf->\{(.+?)\}/,
  qr/\$\D+?->\{conf\}->\{(.+?)\}/
);

my $args = parse_arguments(\@ARGV);
my $search_dir = $args->{PATH} // '/usr/abills/';
my $is_end_slash = substr($search_dir, -1) eq '/';
my $cut_length = length($search_dir) + !$is_end_slash;
my $config_data_dir = 'config_keys';

my $debug = $args->{DEBUG} || 0;

config_vars_search();

sub config_vars_search {
  my @DIRS = ($search_dir, );
  my $options = { wanted => \&file_search };

  if ($args->{get_docs}) {
    return get_docs();
  }

  if ($args->{no_docs}) {
    return no_docs();
  }

  if ($args->{no_page}) {
    return no_page();
  }

  find($options, @DIRS);
  if ($args->{BY_MODULES}) {
    create_json_by_modules({
      DIR => $search_dir,
      CREATE_DIFF => $args->{CREATE_DIFF}
    });
  } else {
    print_result();
  }
}

sub file_search {
  my $name = $File::Find::name;
  my $dir = $File::Find::dir;
  if (-d $name) {
    return 1;
  }

  my $file_name = substr($name, length($dir) + 1);

  if (grep { $_ eq $file_name } @ALLOWED_FILENAMES) {
    file_process($name, $dir);
    return 1;
  }

  my ($extension) = $name =~ /([^.]+)$/;

  if (grep { $_ eq $extension } @ALLOWED_EXTENSIONS) {
    file_process($name, $dir);
    return 1;
  }
}

sub file_process {
  my ($file_path) = @_;

  my $i = 0;
  my $relative_path = substr($file_path, $cut_length);

  open(my $fh, '<', $file_path);
  while(<$fh>) {
    $i++;
    for my $regex (@REGEXPS) {
      my @matches = $_ =~ $regex;
      next if (!@matches);
      for my $match (@matches) {
        if (!exists $CONFIG_DATA{$match}) {
          $CONFIG_DATA{$match} = [];
        }
        push @{$CONFIG_DATA{$match}}, "$relative_path:$i"
      }
    }
  }
  close($fh);
}

sub print_result {
  my $json = _get_configured_json();
  my $result = $json->encode(\%CONFIG_DATA);

  print $result;
}

sub create_json_by_modules {
  my ($attr) = @_;
  my $module_dir = "$attr->{DIR}/Abills/modules";

  opendir my $dh, $module_dir
    or die "$0: opendir: $!";
  my $json = _get_configured_json();

  my @probably_modules = sort grep {-d "$module_dir/$_" && ! /^\.{1,2}$/} readdir($dh);

  my $existingdir = "./$config_data_dir";
  mkdir $existingdir unless -d $existingdir;

  my %OTHER_DATA = %CONFIG_DATA;
  my %ON_MODULE = ();

  for my $module (@probably_modules) {
    my @keys = grep { /$module/gmi } keys %CONFIG_DATA;
    $ON_MODULE{$module} = [];

    my %module_data = ();
    for my $module_keys (@keys) {
      $module_data{$module_keys} = $CONFIG_DATA{$module_keys};
      push @{$ON_MODULE{$module}}, $module_keys;
      delete ($OTHER_DATA{$module_keys});
    }

    my $result = $json->encode(\%module_data);
    _create_n_write_file($existingdir, $module, $result);

    @{$ON_MODULE{$module}} = sort @{$ON_MODULE{$module}}
  }

  if ($attr->{CREATE_DIFF}) {
    my $EXISTING_DATA = eval { _read_json_from_file('abills') };
    _create_diff($EXISTING_DATA, \%CONFIG_DATA, $existingdir);
  }

  my $result = $json->encode(\%CONFIG_DATA);
  _create_n_write_file($existingdir, 'abills', $result);

  $result = $json->encode(\%OTHER_DATA);
  _create_n_write_file($existingdir, 'abills_other', $result);

  $result = $json->encode(\%ON_MODULE);
  _create_n_write_file($existingdir, 'abills_config_modules', $result);
}

sub _create_n_write_file {
  my ($dir, $file_name, $content) = @_;
  open my $fileHandle, ">", "$dir/$file_name.json" or die "Can't open '$dir/$file_name.json'\n";
  print $fileHandle $content;
  close $fileHandle;
}

sub _get_configured_json {
  JSON->new->utf8->space_before(0)->space_after(1)->indent(1)->canonical(1)
}

sub _read_json_from_file {
  my ($filename) = @_;
  my $json_text = do {
    open(my $json_fh, "<:encoding(UTF-8)", "config_keys/$filename.json")
      or die("Can't open \"$filename\": $!\n");
    local $/;
    <$json_fh>
  };
  my $json = JSON->new;
  $json->decode($json_text)
}

sub _create_diff {
  my ($EXISTING_DATA, $CONFIG_DATA, $dir) = @_;

  if (!$EXISTING_DATA) {
    return;
  }

  my @minus_keys = ();
  my @plus_keys = ();

  my %COPIED_CONFIG = %{$CONFIG_DATA};
  my %COPIED_EXIST = %{$EXISTING_DATA};

  for my $new_key (keys %COPIED_CONFIG) {
    if (!defined($COPIED_EXIST{$new_key})) {
      push @plus_keys, $new_key;
    }
  }

  for my $old_key (keys %COPIED_EXIST) {
    if (!defined($COPIED_CONFIG{$old_key})) {
      push @minus_keys, $old_key;
    }
  }

  if (@plus_keys || @minus_keys) {
    my $json = _get_configured_json();
    my $result = $json->encode({
      plus  => \@plus_keys,
      minus => \@minus_keys,
    });

    my $date = strftime "%Y%m%d", localtime;
    _create_n_write_file($dir, "diff_$date", $result);
  }
}

sub _parse_config_sql {
  my $file = "$Bin/../db/config_variables.sql";

  my @params = ();

  open(my $fh, '<', $file) or die "Could not open file '$file' $!";

  while (my $line = <$fh>) {
    if ($line =~ /'([^']+)'/) {
      push @params, $1;
    }
  }

  close($fh);

  return \@params;
}

sub _search_doc  {
  my ($attr) = @_;

  my $main_url = 'http://abills.net.ua/wiki';

  my $doc_url = q{};

  if ($attr->{CONF}) {
    $attr->{WORD}=$attr->{CONF};
    $attr->{WORD} =~ s/$attr->{WORD}/\$conf{$attr->{WORD}}/g;
  }

  if ($attr->{WORD} =~ /on\s+page|\$/) {
    $attr->{WORD} .= ' ' if ($attr->{WORD} !~ /\$/);
    $attr->{WORD} =~ s/\s+on\s+page\s+//g;
    $doc_url = "$main_url/rest/api/content/search?limit=500&cql=text~'$attr->{WORD}'";
  }
  else {
    $doc_url = "$main_url/rest/api/content/search?limit=500&cql=title~'$attr->{WORD}'";
  }

  if ($debug > 3) {
    print "Request: $doc_url\n";
  }

  my $response = web_request($doc_url,
    {
      CURL        => 1,
      JSON_RETURN => 1,
      JSON_UTF8   => 1
    }
  );

  my $count = 0;
  my $text = q{};
  my $possible_webui = q{};

  foreach my $result (@{$response->{results}}) {
    next if ($result->{type} ne 'page');
    $count++;
    my $web_link = $main_url . $result->{_links}->{webui};
    my $api_url = $main_url . "/rest/api/content/$result->{id}?expand=body.view";
    $text .= "$result->{title} URL: $web_link\n";
    if($attr->{WORD} =~ /\$/) {
      my $result = _parse_page($api_url, $attr->{WORD});

      if ($result) {
        return ($result, $web_link);
      }
      $possible_webui = $web_link;
    }
  }

  if ($possible_webui) {
    return ($possible_webui);
  }

  return ()
}

#**********************************************************
=comments parse_page($page, $word)

  Arguments:
    $page
    $word

  Results:
    $context

=cut
#**********************************************************
sub _parse_page  {
  my ($api_url, $conf, $webui_url)=@_;
  my $result = q{};

  my $word = $conf;
  $word =~ s/\{/\\\{/g;  # Escapes all '{' by replacing with '\{'
  $word =~ s/\}/\\\}/g;  #

  if ($debug > 3) {
    print "PAGE: $api_url\n";
  }

  my $response = web_request($api_url,
    {
      CURL        => 1,
      JSON_RETURN => 1,
      JSON_UTF8   => 1
    }
  );

  my $context = $response->{body}{view}{value};

  #$word = '\$conf{dbhost}';
  $word =~ s/\$/\\\$/g;
  #print "- $word -";
  $context =~ s/<br\/>/ /ig;

  if ($context =~ />$word\s?=\s?([a-z0-9'"\_@\,]+);<\/th><td class=\"confluenceTd\">([\W\_\-\.\,0-9\(\)\s]+)<\/td><\/tr>/ig
    || $context =~ />$word\s?=\s?([a-z0-9'"\_@\,]+);<\/th><td class=\"confluenceTd\">(.+)<\/td><\/tr><tr/ig
    || $context =~ />$word\s?=\s?([a-z0-9'"\_@\,]+);<\/th><td class=\"confluenceTd\">(.+)<\/td><\/tr>/ig ) {
    $result   = $2;
    my $value = $1;

    print " Value: $value \n Describe: $result\n URL: $webui_url\n" if ($debug > 1);
  }

  return $result;
}

sub _make_docs_search {
  my $config_keys = _parse_config_sql();

  my %variables = map { $_ => [] } @$config_keys;

  for my $key (sort keys %variables) {
    my @res = _search_doc({ CONF => $key });
    $variables{$key} = \@res;
  }

  return \%variables;
}

sub _load_variables_from_cache {
  my ($file) = @_;
  my $result = q{};
  open(my $fh, '<', $file) or die "Could not open file '$file' $!";
  while (my $line = <$fh>) {
    $result .= $line;
  }
  close($fh);

  my $json = _get_configured_json();
  return $json->decode($result);
}

sub get_docs {
  my $variables = _make_docs_search();

  my $json = _get_configured_json();
  my $result = $json->encode($variables);

  print $result;
}

sub no_docs {
  my $variables = {};

  if ($args->{CACHE}) {
    $variables = _load_variables_from_cache($args->{CACHE})
  }
  else {
   $variables = _make_docs_search();
  }

  for my $key (sort keys %$variables) {
    # 2 = result, url;
    # 1 = url;
    # 0 = no page;
    my $len = scalar(@{$variables->{$key}});

    if ($len != 1) {
      delete $variables->{$key};
    }
  }

  my $json = _get_configured_json();
  my $result = $json->encode($variables);

  print $result;
}

sub no_page {
  my $variables = {};

  if ($args->{CACHE}) {
    $variables = _load_variables_from_cache($args->{CACHE})
  }
  else {
    $variables = _make_docs_search();
  }

  for my $key (sort keys %$variables) {
    # 2 = result, url;
    # 1 = url;
    # 0 = no page;
    my $len = scalar(@{$variables->{$key}});

    if ($len != 0) {
      delete $variables->{$key};
    }
  }

  my $json = _get_configured_json();
  my $result = $json->encode($variables);

  print $result;
}

1;