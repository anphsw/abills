#!perl
=head1 NAME

  Events

=cut
use strict;
use warnings 'FATAL' => 'all';

use Abills::Base qw/_bp/;
use Abills::Experimental;

our (
  %lang,
  $html,
  $admin, $db, %conf,
  %permissions,
  @DEFAULT_SEND_TYPES,
  @PRIORITY_SEND_TYPES
);


use Events;
our Events $Events = Events->new($db, $admin, \%conf);

require Events::Selects;

if ( $permissions{5} ) {
  require Events::Configure;
}

require Events::Profile;

#$Events->events_add({
#  MODULE   => "Equipment",
#  COMMENTS => "Hello",
#  EXTRA    => "index=23"
#});

#**********************************************************
=head2 events_events($attr)

  Arguments:
    $attr - hash_ref
      CLIENT_INTERFACE - client interface flaf

  Returns:
    JSON aray string

=cut
#**********************************************************
sub events_events {
  my ($attr) = @_;
  my @events_list = ();
  
  # Check if called from cross_modules via User Portal
  if ( $attr->{CLIENT_INTERFACE} ) {
    return '';
  }
  
  my $events_index = get_function_index('events_main') || 0;
  my $seen_index = get_function_index('events_seen_message') || 0;
  #  return 'no_index' if ($events_index == 0);
  
  my $events_list = $Events->events_list({ STATE_ID => 1, SHOW_ALL_COLUMNS => 1 });
  
  my %group_enabled = (1 => 1);
  my $group_ids = $admin->{SETTINGS}->{GROUP_ID} || '';
  if ( $group_ids ) {
    %group_enabled = map {$_ => 1} split (',\s?', $group_ids);
  }
  
  # System group is always enabled
  $group_enabled{1} = 1;
  
  eval {
    require JSON;
    JSON->import('to_json');
  };
  if ($@){
    return $@;
  }
  
  foreach my $event ( @{$events_list} ) {
    
    if ( $event->{group_id} && !$group_enabled{$event->{group_id}} ) {
      if ( $FORM{DEBUG} && $FORM{DEBUG} > 3 ) {
        _bp('Skipping', [ $event->{group_id}, $group_enabled{$event->{group_id}}, \%group_enabled ],
          { TO_CONSOLE => 1 }
        );
      }
      next;
    };
    
    $event->{message} = do {
      if ( $event->{comments} =~ /\_\{(\w+)\}\_/ && exists $lang{$1} && defined $lang{$1} ) {
        $event->{comments} =~ s/\_\{(\w+)\}\_/$lang{$1}/sg;
      }
      $event->{comments};
    };
    
    $event->{subject} = $event->{title} || $event->{module} || '';
    
    if ( $event->{subject} =~ /\_\{(\w+)\}\_/ && exists $lang{$1} && defined $lang{$1} ) {
      $event->{subject} =~ s/\_\{(\w+)\}\_/$lang{$1}/sg;
    }
    
    $event->{extra} ||= "$SELF_URL?index=$events_index&chg=$event->{id}";
    
    push(@events_list, events_event_to_json($event, $seen_index));
  }
  
  return join(", ", @events_list);
}

#**********************************************************
=head2 events_event_to_json($message)

  Function to format message to JSON structure needed in AMessageChecker

  Arguments:
    $message - hash_ref of message from DB
      subject   - Subject of message
      message   - Text of message

    $msgs_index - index to see message

  Returns:
    JSON structure for message

=cut
#**********************************************************
sub events_event_to_json {
  my ($event, $seen_index) = @_;
  
  $event->{subject} ||= $lang{ERR_NO_TITLE};
  $event->{message} ||= $lang{ERR_NO_MESSAGE};
  
  return JSON::to_json({
    "TYPE"        => "EVENT",
    "TITLE"       => $event->{subject},
    "CREATED"     => $event->{created},
    "TEXT"        => $event->{message},
    "EXTRA"       => $event->{extra},
    "MODULE"      => $event->{module},
    "GROUP_ID"    => $event->{group_id},
    "ID"          => $event->{id},
    "NOTICED_URL" => "?qindex=$seen_index&json=1&AJAX=1&header=2&ID=$event->{id}"
  });
}


1;